#!/bin/zsh -e

typeset PROG=$0
typeset NAME=$0:t
typeset -a targets
typeset dryrun=false verbose=false

[[ -n $BB_ROOT ]] || export BB_ROOT=/var/local/backup
cd $BB_ROOT

main() {
    [[ $NAME == bb* ]] || usage
    typeset cmd=${NAME[3,-1]}
    case $cmd in
        (op) backup "$@" ;;
        (*)  cmd_$cmd "$@" ;;
    esac
}

backup() {
    typeset opt yes=false all=false
    while getopts :nya opt; do
        case $opt in
            (n) dryrun=true ;;
            (v) verbose=true ;;
            (y) yes=true ;;
            (a) all=true ;;
            (*) usage ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    if (( $# == 0 )); then
        $all || usage
        if ! $yes && [[ -t 0 ]]; then
            askbool 'Back up all targets?' || cancel
            yes=true
        fi
        set -- $(zubak lt)
    fi
    targets=( $(targets $@) )
    (( $#targets > 0 )) || fatal 'nothing to back up'
    if ! $yes && [[ -t 0 ]]; then
        print 'Targets selected for backup:' >&2
        for t in $targets; do print "  * $t"; done >&2
        askbool 'OK to proceed?' || cancel
    fi
    for t in $targets; do
        run zubak up $t
    done
}

cmd_last() {
    targets=( $(targets "$@") )
    printf '%-16s  %6s  %6s  %7s  %s\n' Date Files Size 'Tape(s)' Target
    for t in $targets; do
        s=current
        for b in $(zubak lb $t $s | tail -n1); do
            parse-date $b | read y m d H M S
            bsize=$(backup-size $t $s $b)
            bcount=$(backup-count $t $s $b)
            tapes="$(backup-tapes $t $s $b)"
            printf '%04d-%02d-%02d %02d:%02d  %6.6s  %6.6s  %7s  %s\n' $y $m $d $H $M $bcount $bsize "$tapes" $t
        done
    done | sort
}

# --- Functions

note() {
    if [[ -t 1 ]]; then
        print -- "\e[35;1m$*\e[0m"
    else
        print -- "$*"
    fi
}

run() {
    note "$*"
    $dryrun && print '  (dry run)' || "$@"
}

askbool() {
    read -q "?$1 [yN] "
    integer err=$?
    [[ $REPLY == $'\n' ]] || print
    return $err
}

find-on-tape() {
    while read t s b m; do
        f=$(perl -e '$m=shift; $m =~ m{[^/]+(.+)}; print $1, "\n"')
        if [[ ! -e $s/$b.t0receipt ]]; then
            print "$t $s $b <> $m"
            continue
        fi
        #print perl -ne ... $t $s $b "'$m'" \< $PWD/$s/$b.t0receipt >&2
        perl -e '
            BEGIN { ($tape, $n, $tgt, $s, $bkup, $m) = (qw(- -), @ARGV) }
            die if $m !~ /^\^(\d+)/;
            $b = $1;
            die if $m !~ m{[^/]+(/.*)};
            $f = $1;
            while (<STDIN>) {
                if (/^J (\S+)/) {
                    $j = $1;
                }
                elsif (/^T (\S+) filenum (\d+)/) {
                    ($tape, $n) = ($1, $2);
                }
                elsif (/^F (\d+) (\S+)\.(\d+)\.gz/) {
                    if ($3 == $b) {
                        print "$tgt $s $bkup <$j:$b:$tape:$n> $m\n";
                    }
                }
            }
        ' $t $s $b $m < $s/$b.t0receipt
    done
}

strip-final-slashes() {
    typeset f=$1
    while (( $#f > 1 )) && [[ $f == */ ]]; do
        # Strip final /, //, etc.
        f="${f[1,-2]}"
    done
    print -- "$f"
}

parse-date() {
    print ${1[1,4]} ${1[5,6]} ${1[7,8]} ${1[10,11]} ${1[12,13]} ${1[14,15]}
}

targets() {
    targets=()
    for t in $@; do
        if [[ $t == */* ]]; then
            targets+=$t
        elif [[ -e clients/$t ]]; then
            targets+=( $(zubak lt | grep "^$t/") )
        elif [[ -e targets/$t ]]; then
            targets+=$t
        else
            fatal "no such target: $t"
        fi
    done
    (( $#targets > 0 )) || targets=( $(zubak lt) )
    print -l $targets
}

backup-size() {
    typeset t=$1 s=$2 b=$3
    du -hc targets/$t/series/$s/$b.* | awk '{t=$1} END {print t}'
}

backup-count() {
    typeset t=$1 s=$2 b=$3
    grep -c '^+' targets/$t/series/$s/$b.eum | num2hum
}

backup-tapes() {
    typeset t=$1 s=$2 b=$3
    typeset rcpt=targets/$t/series/$s/$b.t0receipt
    [[ ! -e $rcpt ]] || perl -ne '$t{$1}++ if /^T (\S+)/; END { print $_, "\n" for sort keys %t }' $rcpt
}

usage() {
    print "usage: ${PROG:t} CMD [ARG...]" >&2
    exit 1
}

cancel() {
    print Cancelled >&2
    exit 0
}

fatal() {
    print ${PROG:t}: "$@" >&2
    exit 2
}

main "$@"
