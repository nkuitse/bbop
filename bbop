#!/bin/zsh -e

typeset PROG=$0
typeset NAME=$0:t
typeset -a targets
typeset dryrun=false verbose=false

[[ -n $BB_ROOT ]] || export BB_ROOT=/var/local/backup

main() {
    [[ -x $BB_ROOT ]] || fatal "root $BB_ROOT not accessible"
    cd $BB_ROOT || return
    [[ $NAME == bb* ]] || usage
    typeset cmd=${NAME[3,-1]}
    case $cmd in
        (op) backup "$@" ;;
        (*)  cmd_$cmd "$@" ;;
    esac
}

backup() {
    typeset opt yes=false all=false
    typeset -a zubakopts
    while getopts :nvyal opt; do
        case $opt in
            (n) dryrun=true ;;
            (v) verbose=true ;;
            (y) yes=true ;;
            (a) all=true ;;
            (l) zubakopts+=( -l ) ;;
            (*) usage ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    if (( $# == 0 )); then
        $all || usage
        if ! $yes && [[ -t 0 ]]; then
            askbool 'Back up all targets?' || cancel
            yes=true
        fi
        set -- $(zubak lt)
    fi
    targets=( $(targets $@) )
    (( $#targets > 0 )) || fatal 'nothing to back up'
    if ! $yes && [[ -t 0 ]]; then
        print 'Targets selected for backup:' >&2
        for t in $targets; do print "  * $t"; done >&2
        askbool 'OK to proceed?' || cancel
    fi
    for t in $targets; do
        print "Back up $t" >&2
        run zubak up $zubakopts $t
    done
    print 'Write jobs to tape' >&2
    t0write -a
    print 'Done' >&2
}

cmd_start() {
    typeset opt all=false
    typeset -a bbargs
    while getopts :vya opt; do
        case $opt in
            (v) bbargs+=( -v ) ;;
            (y) yes=true ;;
            (a) all=true; bbargs+=( -a ) ;;
            (*) usage ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    if (( $# == 0 )); then
        $all || usage
        if ! $yes && [[ -t 0 ]]; then
            askbool 'Back up all targets?' || cancel
        fi
        set -- $(zubak lt)
    fi
    targets=( $(targets $@) )
    $all || (( $#targets > 0 )) || fatal 'nothing to back up'
    bbop -y $bbargs $targets > bbop.$$.log 2>&1 &
}

cmd_last() {
    typeset opt mode all=false
    while getopts :afi opt; do
        case $opt in
            (a) all=true ;;
            (f) mode=full ;;
            (i) mode=incr ;;
            (*) usage ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    targets=( $(targets "$@") )
    printf '%-16s  %4s  %6s  %6s  %7s  %s\n' Date Mode Files Size 'Tape(s)' Target
    typeset -a batches
    for t in $targets; do
        s=current
        batches=( $(zubak lb $t $s | tac) )
        if (( $#batches == 0 )); then
            ! $all || print -- "---------- --:--  ----       -       -        -  $t"
            continue
        fi
        for b in $batches; do
            bmode=$(backup-mode $t $s $b)
            if [[ -z $mode || $bmode == $mode ]]; then
                parse-date $b | read y m d H M S
                bsize=$(backup-size $t $s $b)
                bcount=$(backup-count $t $s $b)
                tapes="$(backup-tapes $t $s $b)"
                printf '%04d-%02d-%02d %02d:%02d  %4s  %6.6s  %6.6s  %7s  %s\n' $y $m $d $H $M $bmode $bcount $bsize "$tapes" $t
                $all || break
            fi
        done
    done | sort
}

cmd_new() {
    typeset opt host root
    (( $# == 1 )) || usage TARGET
    typeset t=$1; shift
    case $t in
        (*/*)
            host=$t:h
            root=/$t:t
            [[ $host$root == $t ]] || usage TARGET
            ;;
    esac
    typeset host=$( { print $HOST:r; hostname -s } | sort -u | fgrep -v . )
    typeset t="${argv[-1]}"
    [[ ! -e targets/$t ]] || fatal "target already exists: $t"
    zubak nt "$@"
    [[ -e targets/$t ]] || fatal "target not created: $t"
    [[ -e targets/$t/bin/zubak-begin ]] || make-zubak-begin $t $host
    [[ -e targets/$t/bin/zubak-end   ]] || make-zubak-end   $t $host
    make-zubak-find $t $host $root
}

make-zubak-find() {
    typeset t=$1 host=$2 root=$3
    typeset -a roots
    case $root in
        (user) roots=( ${host}:/home ${host}:root ) ;;
        (*)    roots=( ${host}:/${root} ) ;;
    esac
    cat > targest/$t/bin/zubak-find <<EOS
#!/bin/zsh -e
find $roots ...
EOS
}

make-zubak-begin() {
    typeset t=$1 host=$2
    if [[ $h != $(hostname -s) && $h != $HOST:r ]]; then
        print 'Create zubak-begin' >&2
        cat > targets/$t/bin/zubak-begin <<EOS
#!/bin/zsh -e
mkdir ${host}:
sshfs ${host}:/ ${host}:/
sleep 1
EOS
        chmod a+x targets/$t/bin/zubak-begin
    fi
}

make-zubak-end() {
    typeset t=$1 host=$2
    if [[ $h != $(hostname -s) && $h != $HOST:r ]]; then
        print 'Create zubak-end' >&2
        cat > targets/$t/bin/zubak-end <<EOS
#!/bin/zsh -e
umount ${host}:
rmdir ${host}:
exec zubak-mkt0job "$@"
EOS
        chmod a+x targets/$t/bin/zubak-end
    fi
}

cmd_conf() {
    targets=( $(targets "$@") )
    (( $#targets == 1 )) || fatal 'no targets found'
}

# --- Functions

note() {
    if [[ -t 1 ]]; then
        print -- "\e[35;1m$*\e[0m"
    else
        print -- "$*"
    fi
}

run() {
    note "$*"
    $dryrun && print '  (dry run)' || "$@"
}

askbool() {
    read -q "?$1 [yN] "
    integer err=$?
    [[ $REPLY == $'\n' ]] || print
    return $err
}

find-on-tape() {
    while read t s b m; do
        f=$(perl -e '$m=shift; $m =~ m{[^/]+(.+)}; print $1, "\n"')
        if [[ ! -e $s/$b.t0receipt ]]; then
            print "$t $s $b <> $m"
            continue
        fi
        #print perl -ne ... $t $s $b "'$m'" \< $PWD/$s/$b.t0receipt >&2
        perl -e '
            BEGIN { ($tape, $n, $tgt, $s, $bkup, $m) = (qw(- -), @ARGV) }
            die if $m !~ /^\^(\d+)/;
            $b = $1;
            die if $m !~ m{[^/]+(/.*)};
            $f = $1;
            while (<STDIN>) {
                if (/^J (\S+)/) {
                    $j = $1;
                }
                elsif (/^T (\S+) filenum (\d+)/) {
                    ($tape, $n) = ($1, $2);
                }
                elsif (/^F (\d+) (\S+)\.(\d+)\.gz/) {
                    if ($3 == $b) {
                        print "$tgt $s $bkup <$j:$b:$tape:$n> $m\n";
                    }
                }
            }
        ' $t $s $b $m < $s/$b.t0receipt
    done
}

strip-final-slashes() {
    typeset f=$1
    while (( $#f > 1 )) && [[ $f == */ ]]; do
        # Strip final /, //, etc.
        f="${f[1,-2]}"
    done
    print -- "$f"
}

parse-date() {
    print ${1[1,4]} ${1[5,6]} ${1[7,8]} ${1[10,11]} ${1[12,13]} ${1[14,15]}
}

targets() {
    (( $# > 0 )) || targets=( $(zubak lt) )
    for t in $@; do
        if [[ $t == */* ]]; then
            targets+=$t
        elif [[ -e targets/$t/series ]]; then
            targets+=$t
        else
            targets+=( $(zubak lt | grep "^$t/") )
        fi
    done
    (( $#targets > 0 )) || fatal "no such target: $t"
    print -l $targets
}

backup-size() {
    typeset t=$1 s=$2 b=$3
    du -hc targets/$t/series/$s/$b.* | awk '{t=$1} END {print t}'
}

backup-mode() {
    typeset t=$1 s=$2 b=$3
    awk '/^mode / {print $2; exit}' targets/$t/series/$s/$b.backup
}

backup-count() {
    typeset t=$1 s=$2 b=$3
    grep -c '^+' targets/$t/series/$s/$b.eum | num2hum
}

backup-tapes() {
    typeset t=$1 s=$2 b=$3
    typeset rcpt=targets/$t/series/$s/$b.t0receipt
    [[ ! -e $rcpt ]] || perl -ne '$t{$1}++ if /^T (\S+)/; END { print $_, "\n" for sort keys %t }' $rcpt
}

usage() {
    print "usage: ${PROG:t} ${1:-'[-nvy] [-a|TARGET|CLIENT...'}" >&2
    exit 1
}

cancel() {
    print Cancelled >&2
    exit 0
}

fatal() {
    print ${PROG:t}: "$@" >&2
    exit 2
}

main "$@"
