#!/bin/zsh -e

typeset PROG=$0
typeset NAME=$0:t
typeset -a targets
typeset dryrun=false verbose=false

[[ -n $BB_ROOT ]] || export BB_ROOT=/var/local/backup

main() {
    [[ -x $BB_ROOT ]] || fatal "root $BB_ROOT not accessible"
    cd $BB_ROOT || return
    [[ $NAME == bb* ]] || usage
    typeset cmd=${NAME[3,-1]}
    case $cmd in
        (op) backup "$@" ;;
        (*)  cmd_$cmd "$@" ;;
    esac
}

backup() {
    typeset opt yes=false all=false
    typeset -a zubakopts
    while getopts :nvyal opt; do
        case $opt in
            (n) dryrun=true ;;
            (v) verbose=true ;;
            (y) yes=true ;;
            (a) all=true ;;
            (l) zubakopts+=( -l ) ;;
            (*) usage ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    if (( $# == 0 )); then
        $all || usage
        if ! $yes && [[ -t 0 ]]; then
            askbool 'Back up all targets?' || cancel
            yes=true
        fi
        set -- $(zubak lt)
    fi
    targets=( $(targets $@) )
    (( $#targets > 0 )) || fatal 'nothing to back up'
    if ! $yes && [[ -t 0 ]]; then
        print 'Targets selected for backup:' >&2
        for t in ${(u)targets}; do print "  * $t"; done >&2
        askbool 'OK to proceed?' || cancel
    fi
    for t in ${(u)targets}; do
        $dryrun || print "Back up $t" >&2
        run zubak up $zubakopts $t
    done
    $dryrun || print 'Write jobs to tape' >&2
    run t0write -a
    print 'Done' >&2
}

cmd_start() {
    typeset opt all=false
    typeset -a bbargs
    while getopts :vya opt; do
        case $opt in
            (v) bbargs+=( -v ) ;;
            (y) yes=true ;;
            (a) all=true; bbargs+=( -a ) ;;
            (*) usage ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    if (( $# == 0 )); then
        $all || usage
        if ! $yes && [[ -t 0 ]]; then
            askbool 'Back up all targets?' || cancel
        fi
        set -- $(zubak lt)
    fi
    targets=( $(targets $@) )
    $all || (( $#targets > 0 )) || fatal 'nothing to back up'
    $PROG -y $bbargs $targets > bbop.$$.log 2>&1 &
}

cmd_last() {
    typeset opt mode all=false
    while getopts :afi opt; do
        case $opt in
            (a) all=true ;;
            (f) mode=full ;;
            (i) mode=incr ;;
            (*) usage ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    targets=( $(targets "$@") )
    printf '%-16s  %4s  %6s  %6s  %7s  %s\n' Date Mode Files Size 'Tape(s)' Target
    typeset -a batches
    for t in $targets; do
        s=current
        batches=( $(zubak lb $t $s | tac) )
        if (( $#batches == 0 )); then
            ! $all || print -- "---------- --:--  ----       -       -        -  $t"
            continue
        fi
        for b in $batches; do
            bmode=$(backup-mode $t $s $b)
            if [[ -z $mode || $bmode == $mode ]]; then
                parse-date $b | read y m d H M S
                bsize=$(backup-size $t $s $b)
                bcount=$(backup-count $t $s $b)
                tapes="$(backup-tapes $t $s $b)"
                printf '%04d-%02d-%02d %02d:%02d  %4s  %6.6s  %6.6s  %7s  %s\n' $y $m $d $H $M $bmode $bcount $bsize "$tapes" $t
                $all || break
            fi
        done
    done | sort
}

cmd_new() {
    typeset opt host root
    (( $# == 1 )) || usage TARGET
    typeset t=$1; shift
    case $t in
        (*/*)
            host=$t:h
            root=/$t:t
            [[ $host$root == $t ]] || usage TARGET
            ;;
    esac
    typeset host=$( { print $HOST:r; hostname -s } | sort -u | fgrep -v . )
    typeset t="${argv[-1]}"
    [[ ! -e targets/$t ]] || fatal "target already exists: $t"
    zubak nt "$@"
    [[ -e targets/$t ]] || fatal "target not created: $t"
    [[ -e targets/$t/bin/zubak-begin ]] || make-zubak-begin $t $host
    [[ -e targets/$t/bin/zubak-end   ]] || make-zubak-end   $t $host
    make-zubak-find $t $host $root
}

cmd_conf() {
    targets=( $(targets "$@") )
    (( $#targets == 1 )) || fatal 'no targets found'
}

cmd_queue() {
    typeset opt q qheld list=true add=false clear=false release=false hold=false tally=false dly wly mly
    typeset -a targets queues
    print -P '%D{d%H w%a m%d}' | tr A-Z a-z | read dly wly mly
    while getopts :vakhutldwm opt; do
        case $opt in
            (v) verbose=true ;;
            (a) add=true ;;
            (k) clear=true ;;
            (h) hold=true ;;
            (u) release=true ;;
            (t) tally=true ;;
            (l) list=true ;;
            (d) queues+=( $dly ) ;;
            (w) queues+=( $wly ) ;;
            (m) queues+=( $mly ) ;;
            (*) usage ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    if $add; then
        (( $#queues < 2 )) || usage
        (( $#queues == 0 )) || set $queues $@
        (( $# > 1 )) || usage
        q=$1; shift
        if [[ $q != [0-9] && $q != m[0-9][0-9] && $q != w[a-z][a-z][a-z] && $q != d[0-9][0-9] ]]; then
            print "bbqueue: warning: adding to a non-standard queue: $q" >&2
        fi
        ! $hold || q=${q}+
        print -l $(targets "$@") >> queue/$q
    elif $clear; then
        set -- $queues $@
        (( $# )) || usage
        for q in $@:t; do
            ! $hold || q=${q}+
            [[ ! -s queue/$q ]] || : > queue/$q
        done
    elif $hold; then
        set -- $queues $@
        (( $# )) || set -- queue/$dly(.N) queue/$wly(.N) queue/$mly(.N)
        (( $# )) || return 0
        for q in $@:t; do
            ! isempty queue/$q || continue 
            qheld=${q}+
            if [[ -e queue/$qheld ]]; then
                cat queue/$q >> queue/$qheld
                : > rm queue/$q
            else
                mv queue/$q queue/$qheld
            fi
        done
    elif $release; then
        set -- $queues $@
        (( $# )) || set -- queue/$dly+(.N) queue/$wly+(.N) queue/$mly+(.N)
        (( $# )) || return 0
        for q in $@:t; do
            if [[ $q == *+ ]]; then
                qheld=$q
                q=${q[1,-2]}
            else
                qheld=${q}+
            fi
            if [[ -e queue/$q ]]; then
                if [[ -e queue/$qheld ]]; then
                    cat queue/$qheld >> queue/$q
                    rm queue/$qheld
                fi
            elif [[ -e queue/$qheld ]]; then
                mv queue/$qheld queue/$q
            fi
        done
    elif $tally; then
        set -- $queues $@
        (( $# )) || set -- queue/[0-9](.N) queue/$dly(.N) queue/$wly(.N) queue/$mly(.N)
        if $verbose; then
            for q in $@:t; do
                if [[ -e queue/$q ]]; then
                    wc -l queue/$q
                else
                    print 0 $q
                fi | sed s:queue/::
            done
        else
            for q in $@:t; do
                [[ ! -e queue/$q ]] || cat queue/$q
            done | sort -u | wc -l
        fi
    else
        set -- $queues $@
        (( $# )) || set -- queue/[0-9](.N) queue/$dly(.N) queue/$wly(.N) queue/$mly(.N)
        (( $# )) || exit 0
        if $verbose; then
            for q in $@:t; do
                [[ ! -e queue/$q ]] || sort -u queue/$q | sed "s/^/$q /"
            done
        else
            for q in $@:t; do
                [[ ! -s queue/$q ]] || targets+=( $(cat queue/$q) )
            done
            targets=( ${(u)targets} )
            (( $#targets == 0 )) || print -l ${(u)targets}
        fi
    fi
}

cmd_run() {
    typeset opt q dly wly mly
    typeset -a queues targets backupargs
    queues=( queue/*@(.N) )
    (( $#queues == 0 )) || fatal "the queue is running: $queues"
    print -P '%D{d%H w%a m%d}' | tr A-Z a-z | read dly wly mly
    while getopts :nyvadwm opt; do
        case $opt in
            (n) dryrun=true; backupargs+=( -n ) ;;
            (y) backupargs+=( -y ) ;;
            (v) verbose=true; backupargs+=( -v ) ;;
            (a) queues=( queue/[0-9](.N) queue/$dly(.N) queue/$wly(.N) queue/$mly(.N) )
                (( $#queues )) || exit 0
                ;;
            (d) queues+=( queue/$dly(.N) ) ;;
            (w) queues+=( queue/$wly(.N) ) ;;
            (m) queues+=( queue/$mly(.N) ) ;;
            (*) usage ;;
        esac
    done
    shift $(( OPTIND - 1 ))
    if (( $#queues == 0 )); then
        (( $# )) || usage
        for q in $@:t; do
            [[ -e queue/$q ]] || fatal "no such queue: $q"
            queues+=( queue/$q )
        done
    fi
    targets=( $(cat $queues) )
    (( $#targets )) || return 0
    for q in $queues:t; do
        $dryrun || mv queue/$q queue/$q@
    done
    run backup $backupargs ${(u)targets}
    for q in $queues:t; do
        if $dryrun; then
            :
        elif [[ $q == [0-9] ]]; then
            rm queue/$q@
            : > queue/$q
        elif [[ -e queue/$q+ ]]; then
            rm queue/$q@
        else
            mv queue/$q@ queue/$q+
        fi
    done
}

# --- Functions

isempty() {
    [[ ! -s $1 ]]
}

note() {
    if [[ -t 1 ]]; then
        print -- "\e[35;1m$*\e[0m"
    else
        print -- "$*"
    fi
}

run() {
    if $verbose; then
        note "$*"
        $dryrun && print '  (dry run)'
    fi
    $dryrun || "$@"
}

askbool() {
    read -q "?$1 [yN] "
    integer err=$?
    [[ $REPLY == $'\n' ]] || print
    return $err
}

make-zubak-find() {
    typeset t=$1 host=$2 root=$3
    typeset -a roots
    case $root in
        (user) roots=( ${host}:/home ${host}:root ) ;;
        (*)    roots=( ${host}:/${root} ) ;;
    esac
    cat > targest/$t/bin/zubak-find <<EOS
#!/bin/zsh -e
find $roots ...
EOS
}

make-zubak-begin() {
    typeset t=$1 host=$2
    if [[ $host != $(hostname -s) && $host != $HOST:r ]]; then
        print 'Create zubak-begin' >&2
        cat > targets/$t/bin/zubak-begin <<EOS
#!/bin/zsh -e
mkdir ${host}:
sshfs ${host}:/ ${host}:/
sleep 1
EOS
        chmod a+x targets/$t/bin/zubak-begin
    fi
}

make-zubak-end() {
    typeset t=$1 host=$2
    if [[ $host != $(hostname -s) && $host != $HOST:r ]]; then
        print 'Create zubak-end' >&2
        cat > targets/$t/bin/zubak-end <<EOS
#!/bin/zsh -e
umount ${host}:
rmdir ${host}:
exec zubak-mkt0job "$@"
EOS
        chmod a+x targets/$t/bin/zubak-end
    fi
}

find-on-tape() {
    while read t s b m; do
        f=$(perl -e '$m=shift; $m =~ m{[^/]+(.+)}; print $1, "\n"')
        if [[ ! -e $s/$b.t0receipt ]]; then
            print "$t $s $b <> $m"
            continue
        fi
        #print perl -ne ... $t $s $b "'$m'" \< $PWD/$s/$b.t0receipt >&2
        perl -e '
            BEGIN { ($tape, $n, $tgt, $s, $bkup, $m) = (qw(- -), @ARGV) }
            die if $m !~ /^\^(\d+)/;
            $b = $1;
            die if $m !~ m{[^/]+(/.*)};
            $f = $1;
            while (<STDIN>) {
                if (/^J (\S+)/) {
                    $j = $1;
                }
                elsif (/^T (\S+) filenum (\d+)/) {
                    ($tape, $n) = ($1, $2);
                }
                elsif (/^F (\d+) (\S+)\.(\d+)\.gz/) {
                    if ($3 == $b) {
                        print "$tgt $s $bkup <$j:$b:$tape:$n> $m\n";
                    }
                }
            }
        ' $t $s $b $m < $s/$b.t0receipt
    done
}

strip-final-slashes() {
    typeset f=$1
    while (( $#f > 1 )) && [[ $f == */ ]]; do
        # Strip final /, //, etc.
        f="${f[1,-2]}"
    done
    print -- "$f"
}

parse-date() {
    print ${1[1,4]} ${1[5,6]} ${1[7,8]} ${1[10,11]} ${1[12,13]} ${1[14,15]}
}

targets() {
    (( $# > 0 )) || targets=( $(zubak lt) )
    for t in $@; do
        if [[ $t == */* ]]; then
            targets+=$t
        elif [[ -e targets/$t/series ]]; then
            targets+=$t
        else
            targets+=( $(zubak lt | grep "^$t/") )
        fi
    done
    (( $#targets > 0 )) || fatal "no such target: $t"
    print -l $targets
}

backup-size() {
    typeset t=$1 s=$2 b=$3
    du -hc targets/$t/series/$s/$b.* | awk '{t=$1} END {print t}'
}

backup-mode() {
    typeset t=$1 s=$2 b=$3
    awk '/^mode / {print $2; exit}' targets/$t/series/$s/$b.backup
}

backup-count() {
    typeset t=$1 s=$2 b=$3
    grep -c '^+' targets/$t/series/$s/$b.eum | num2hum
}

backup-tapes() {
    typeset t=$1 s=$2 b=$3
    typeset rcpt=targets/$t/series/$s/$b.t0receipt
    [[ ! -e $rcpt ]] || perl -ne '$t{$1}++ if /^T (\S+)/; END { print $_, "\n" for sort keys %t }' $rcpt
}

usage() {
    print "usage: $NAME ${1:-[-nvy] [-a|SUBQUEUE...]}" >&2
    exit 1
}

cancel() {
    print Cancelled >&2
    exit 0
}

fatal() {
    print ${NAME}: "$@" >&2
    exit 2
}

main "$@"
